(此篇只記錄一些廢話，請不要認真看，因為這篇我寫得很隨便，你如果認真看，我會很不好意思)
iptables -t filter -F
iptables -t filter -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -t filter -A INPUT -i lo -s 127.0.0.1 -d 127.0.0.1 -p all -j ACCEPT
iptables -t filter -A INPUT -i eth0 -s 192.168.0.160 -d 192.168.0.160 -p all -j ACCEPT
iptables -t filter -A INPUT -d 192.168.0.160 -p tcp --dport 36000 -j ACCEPT
iptables -t filter -A INPUT -d 192.168.0.160 -p tcp --dport 80 -j ACCEPT
iptables -t filter -A INPUT -d 192.168.0.160 -p tcp --dport 113 -j ACCEPT
iptables -t filter -A INPUT -s 192.168.0.0/24 -d 192.168.0.160 -p icmp -j ACCEPT
iptables -t filter -P INPUT DROP
iptables -t filter -L -nv --line-number

http://serverfault.com/questions/416537/why-does-a-valid-set-of-iptables-rules-slow-my-server-to-a-crawl
http://www.textndata.com/forums/iptables-firewall-making-smtp-pop3-323613.html

啟用本機防火牆之前，需要先載入ip_tables模組
sudo modprobe ip_tables
sudo echo 'ip_tables' >> /etc/modules

參考資料
http://stackoverflow.com/questions/21983554/iptables-v1-4-14-cant-initialize-iptables-table-nat-table-does-not-exist-d

然後又
iptables v1.4.14: can't initialize iptables table `filter': Permission denied (you must be root)

哇草原因是我白爛把firewall.sh放在/etc/profile.d目錄下
應該要在/etc/rc.local裡面呼叫firewall.sh才對，放在/etc/profile.d幹什麼

網關式防火牆 練習1
對外網卡eth0，對內網卡eth1
限制內網的192.168.0.200只能去10.0.1.100寄信(25)或收信(110)
限制內網的192.168.0.0/24所有IP可以存取Internet上面的25(寄信)110(收信) 80(瀏覽網頁無加密) 443(瀏覽網頁有加密)
限制內網的192.168.0.0/24所有IP可以存取Internet上面的udp 53也就是DNS查詢服務

iptables -t filter -F FORWARD
iptables -t filter -A FORWARD -i eth0 -o eth1 -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -t filter -A FORWARD -i eth1 -o eth0 -s 192.168.0.200 -d 10.0.1.100 -p tcp -m multiport --dports 25,110 -j ACCEPT
iptables -t filter -A FORWARD -i eth1 -o eth0 -s 192.168.0.0/24 -p tcp -m multiport --dports 25,110 -j ACCEPT
iptables -t filter -A FORWARD -i eth1 -o eth0 -s 192.168.0.0/24 -p tcp -m multiport --dports 80,443 -j ACCEPT
iptables -t filter -A FORWARD -i eth1 -o eth0 -s 192.168.0.0/24 -p udp --dport 53 -j ACCEPT
iptables -t filter -P FORWARD DROP

nat表的封包流向
以nat CHAIN iptables當作關鍵字，Google圖片搜尋
幾十個網友畫得圖有些出入，仔細研究一下

讓內部網路使用NAT機制上網
對外網卡eth0，對內網卡eth1
iptables -t nat -A POSTROUTING -o eth0 -s 192.168.5.0/24 -j SNAT --to 118.169.0.31
或是不寫外網IP，直接寫成這樣，與上面那一行顯式指定外網IP的指令同等效力
iptables -t nat -A POSTROUTING -o eth0 -s 192.168.5.0/24 -j MASQUERADE
如果外網是撥接式的ADSL，也可能會寫成這樣
iptables -t nat -A POSTROUTING -o ppp0 -s 192.168.5.0/24 -j MASQUERADE

nat多對多(外網有多個IP，但是一定要連續號碼好討厭，感覺是有錢人才有資格下的指令，我家是用二類電信我連TM一個public IP都沒有)
iptables -t nat -A POSTROUTING -o eth0 -s 192.168.5.0/24 -j SNAT --to 118.169.0.31-118.169.0.35

nat一對一
請準備多個public IP，綁在外網的eth0接口
一個eth0綁上多個IP的參考資料
https://wiki.debian.org/NetworkConfiguration#Multiple_IP_addresses_on_One_Interface
防火牆主機上共有三張網卡，eth0對外，eth1是DMZ區，eth2是企業內部網路
eth0綁上了118.169.0.31和118.169.0.32和118.169.0.33
eth1綁上了192.168.0.254
eth2綁上了192.168.1.254
有一台WWW服務器位於DMZ區內，IP是192.168.0.32
有一台Mail服務器也在DMZ區內，IP是192.168.0.33
目前規劃將外部IP:118.169.0.31當成企業內部nat前方的Public IP
外部IP:118.169.0.32要對映到WWW服務器192.168.0.32
外部IP:118.169.0.33要對映到Mail服務器192.168.0.33
從Internet過來的封包，進入我的WWW服務器的配置是
iptables -t nat -A PREROUTING -i eth0 -d 118.169.0.32 -j DNAT --to 192.168.0.32
如果這台WWW服務器有機會它會主動連到Internet，那麼這個也設一下
iptables -t nat -A POSTROUTING -o eth0 -s 192.168.0.32 -j SNAT --to 118.169.0.32

同樣的原理，你可以推出118.169.0.33要映射給內網裡的Mail服務器，要這樣設定
iptables -t nat -A PREROUTING -i eth0 -d 118.169.0.33 -j DNAT --to 192.168.0.33
iptables -t nat -A POSTROUTING -o eth0 -s 192.168.0.33 -j SNAT --to 118.169.0.33

接下來是我一定會用到的Network Address Port Translation (NAPT)
為什麼一定會用到呢？因為我是個窮逼啊~哈哈哈
上面那個一對一NAT還有3個public IP可以用
現實生活裡我大概申請一個就覺得很貴很貴了，所以就用這個方法來作連接埠映射到內網的服務器
描述一下網路環境
外網eth0，IP是118.169.0.31，就只有這一個寶貴的public IP嗚
內網eth1，連接我們服務器放置的DMZ區，IP是192.168.0.254
內網eth2，連接我們企業內網，IP是192.168.1.254
WWW服務器IP是192.168.0.1
Mail服務器IP是192.168.0.2
我們要將Internet送到eth0的80和443 port轉給192.168.0.1
還有將Internet送到eth0的25和110 port轉給192.168.0.2
封包進來eth0設定是
iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j DNAT --to 192.168.0.1:80
iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 443 -j DNAT --to 192.168.0.1:443
iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 25 -j DNAT --to 192.168.0.2:25
iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 110 -j DNAT --to 192.168.0.2:110
讓這兩台服務器的封包可以出去，將來源改成public IP
iptables -t nat -A POSTROUTING -o eth0 -s 192.168.0.0/24 -j SNAT --to 118.169.0.31

再來看到了mangle表的OUTPUT鏈
我還是一樣先用關鍵字
nat chain iptables
搜尋了Google圖片
這個網頁裡畫的那張Iptables Chains Order Scheme
我覺得最容易理解
參考網頁
http://www.gtcomm.net/blog/linux-native-firewall-introduction-to-iptables/
而且它還有特別標上，你在那個表的那個鏈裡面可以幹什麼事

我真的很好奇書上寫的那個mangle表的OUPUT鏈
真的可以換掉封包裡的DSCP資訊嗎？
所以我就試了一下
在我的CubieTruck上面，由於SSH Server是運行在tcp port 36000
在動手前我先用Wireshark抓了一下
這樣子的封包，也就是CubieTruck上的SSH Server發給我筆記型電腦SSH Client的封包
Src : 192.168.0.160
Dst : 192.168.0.12
Src Port : 36000
Dst Port : 51625(這隨機產生的port number，你的一定和我不一樣)
在Internet Protocol Version 4 , Src :192.168.0.160 ......這行打開
下面有個
Differentiated Services Field : 0x10 (DSCP 0x04: Unknown DSCP; ECN: 0x00: Not-ECT (Not ECN-Capable Transport))
的下面那一行
0001 00.. = Diffreentiated Services Codepoint: Unknown (0x04)
在這裡可以確認DSCP的預設值是十進制的4，也就是那個二進制的0001 00
然後在CubieTruck機器上運行這一行iptables規則，來修改從CubieTruck本機發出的tcp 36000 port的封包的DSCP值
iptables -t mangle -A OUTPUT -p tcp --sport 36000 -j DSCP --set-dscp 63
我故意改成十進制的63，這樣如果待會兒真的生效，就會看到原來預設0001 00的地方，會變成1111 11
改完之後，mangle表的規則如下，只有一條
root@cubie:~# iptables -t mangle -L -nv --line-number
Chain PREROUTING (policy ACCEPT 2903 packets, 292K bytes)
num   pkts bytes target     prot opt in     out     source               destination         

Chain INPUT (policy ACCEPT 2903 packets, 292K bytes)
num   pkts bytes target     prot opt in     out     source               destination         

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
num   pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 3222 packets, 413K bytes)
num   pkts bytes target     prot opt in     out     source               destination         
1     1075  188K DSCP       tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp spt:36000 DSCP set 0x3f

Chain POSTROUTING (policy ACCEPT 3222 packets, 413K bytes)
num   pkts bytes target     prot opt in     out     source               destination         
root@cubie:~# 
然後再次打開Wireshark來抓封包
一樣是抓
Src : 192.168.0.160
Dst : 192.168.0.12
Src Port : 36000
Dst Port : 51625(這隨機產生的port number，你的一定和我不一樣)
這種類型的封包，然後觀察DSCP的部分，變成了
1111 11.. = Differentiated Services Codepoint: Unknown (0x3f)
太神奇了，只是改這個要幹什麼呢？
看完這本五百頁的書應該就會知道了，現在才一百零五頁

突然發現這張iptables封包的過濾流程圖也畫得很清楚
而且連raw表也加了進去
http://serverfault.com/questions/523589/is-there-any-way-to-filter-packets-eg-by-iptables-after-routing-is-complete

在防火牆主機上，使用filter表的FORWARD鏈來保護企業內部的WWW服務器(192.168.5.1)不被外部IP 11.22.33.44存取
iptables -t filter -A FORWARD -i eth0 -s 11.22.33.44 -d 192.168.5.1 -j DROP
寫這一行規則的時候，要記得封包到達filter表的FORWARD鏈之前
已經先經過了nat表的PREROUTING鏈 
(已經作了DNAT，已經置換掉了封包的Destination IP)
而且外部的那個想進入企業內存取WWW服務器的封包
原來的Source IP應該是11.22.33.44而Destination IP應該是防火牆eth0上面的外部IP
經過了nat表的PREROUTING鏈之後，這個封包已經變成了
Source IP依然不變是11.22.33.44，但是Destination IP被DNAT變成了192.168.5.1
所以我們在這裡的規則是用 -d 192.168.5.1，而不是-d <eth0接口上綁的企業的public IP>

防火牆主機常見的filter表的FORWARD鏈過濾規則寫法
對外接口eth0，對內接口eth1

1.不允許企業內部用戶訪問www.xvideos.com
iptables -t filter -A FORWARD -p tcp -i eth1 -o eth0 -d www.xvideos.com -j DROP

順便一提，上面的這一句規則會一口氣加上十條規則在FORWARD鏈
原因是www.xvideos.com這個域名有對應到10個IPv4地址
可以這樣用nslookup查詢
$ nslookup www.xvideos.com 8.8.8.8

然後會得到
Server:		8.8.8.8
Address:	8.8.8.8#53

Non-authoritative answer:
www.xvideos.com	canonical name = xvideos.com.
Name:	xvideos.com
Address: 141.0.174.44
Name:	xvideos.com
Address: 141.0.174.34
Name:	xvideos.com
Address: 141.0.174.35
Name:	xvideos.com
Address: 141.0.174.36
Name:	xvideos.com
Address: 141.0.174.37
Name:	xvideos.com
Address: 141.0.174.38
Name:	xvideos.com
Address: 141.0.174.40
Name:	xvideos.com
Address: 141.0.174.41
Name:	xvideos.com
Address: 141.0.174.42
Name:	xvideos.com
Address: 141.0.174.43

看一下加入那條禁看www.xvideos.com的規則之後，filter表的FORWARD鏈規則現在是？
root@cubie:~# iptables -t filter -L FORWARD -nv --line-number
Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
num   pkts bytes target     prot opt in     out     source               destination         
1        0     0 DROP       tcp  --  eth1   eth0    0.0.0.0/0            141.0.174.36        
2        0     0 DROP       tcp  --  eth1   eth0    0.0.0.0/0            141.0.174.43        
3        0     0 DROP       tcp  --  eth1   eth0    0.0.0.0/0            141.0.174.40        
4        0     0 DROP       tcp  --  eth1   eth0    0.0.0.0/0            141.0.174.44        
5        0     0 DROP       tcp  --  eth1   eth0    0.0.0.0/0            141.0.174.38        
6        0     0 DROP       tcp  --  eth1   eth0    0.0.0.0/0            141.0.174.41        
7        0     0 DROP       tcp  --  eth1   eth0    0.0.0.0/0            141.0.174.34        
8        0     0 DROP       tcp  --  eth1   eth0    0.0.0.0/0            141.0.174.37        
9        0     0 DROP       tcp  --  eth1   eth0    0.0.0.0/0            141.0.174.42        
10       0     0 DROP       tcp  --  eth1   eth0    0.0.0.0/0            141.0.174.35        
root@cubie:~# 

2.不允許Internet的11.22.33.44主機訪問公司內部的WWW服務器(192.168.0.1)
iptables -t filter -A FORWARD -i eth0 -o eth1 -s 11.22.33.44 -d 192.168.0.1 -p tcp --dport 80 -j DROP

3.不允許icmp request (type 8)，別人不能ping我，但是我可以ping別人 (突然想起三國的曹操)
iptables -t filter -A FORWARD -p icmp --icmp-type 8 -j DROP

4.不允許內網的用戶使用FTP客戶端下載Internet上的任何東西
iptables -t filter -A FORWARD -i eth1 -o eth0 -s 192.168.0.0/24 -p tcp --dport 21 -j DROP

使用關鍵字3 way handshake
進行Google圖片搜尋

原來的本機防火牆規則的這二條
是我用來放行自定義SSH Server的tcp port 36000
iptables -t filter -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -t filter -A INPUT -d 192.168.0.160 -p tcp --dport 36000 -j ACCEPT

但是這樣不夠嚴謹
可以改成
iptables -t filter -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -t filter -A INPUT -d 192.168.0.160 -p tcp --dport 36000 --syn -m state --state NEW -j ACCEPT

第二行的意思是與本機的tcp port 36000建立tcp連線的過程裡
3 way handshake的第一個封包(-m state--state NEW)裡syn這個flag有設定的話，就放行
這麼作是為了避免黑客在建立tcp連線之前，就直接對tcp port 36000發送fin封包，或是syn和fin這兩個flag都有設定的怪異封包
那種詭異的封包如果通過本機防火牆進入本機程序，不知道會發生什麼事 (要不看到臉，要不看到後腦勺，兩個同時看到就崩潰進神經病院了)
所以這樣的寫法，比先前只是單純讓tcp port 36000打開接受連線，安全強度要更高

同理可推出，那麼我先前的本機防火牆，除了tcp port 36000還開了tcp port 80
那一條「只是打開tcp port 80」的本機防火牆規則是
iptables -t filter -A INPUT -d 192.168.0.160 -p tcp --dport 80 -j ACCEPT
應該要拿掉上面這行，改成下面這一行
iptables -t filter -A INPUT -d 192.168.0.160 -p tcp --dport 80 --syn -m state --state NEW -j ACCEPT

以下規則為所有tcp封包作過濾，檢查封包裡所有的TCP-Flags
當syn和fin同時被標示為1的時候，將此封包丟棄，因為不可能同時既要求連線(syn)又要求斷線(fin)
iptables -t filter -A INPUT -p tcp --tcp-flags ALL SYN,FIN -j DROP

以下規則和上面那條很像，差別是只檢查syn和fin兩個TCP-Flags
當syn和fin同時被標示為1的時候，將此封包丟棄
iptables -t filter -A INPUT -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP

接下來這一條規則也是用在本機防火牆上
想要存取本機tcp port 3306的封包，來源只能是特定mac address的網卡才可以放行
iptables -t filter -A INPUT -p tcp --dport 3306 -m mac --mac-source 9c:d2:1e:f1:0a:53 -j ACCEPT

然後是在防火牆主機上管制網卡mac address的技巧
產生一個可以使用企業網路資源的合法mac address列表，只有裡面記錄的mac address可以使用企業的網路資源
檔名是/root/mac_lists
內容如下
00:0A:C3:82:71:5C
00:22:33:44:55:66

接著在/root/firewall.sh加上
cat /root/mac_lists | while read MAC
do
    MAC=$( echo $MAC | awk '{print $1}' )
    iptables -t filter -A FORWARD -i eth1 -o eth0 -m mac --mac-source $MAC -j ACCEPT
done

再來是multiport的寫法
iptables -t filter -A INPUT -p tcp --syn -m state --state NEW  -m multiport --dports 21,22,23,25,80,110,443 -j ACCEPT

你也可以畫蛇添足，將上面簡單的那一行，改寫成
iptables -t filter -A INPUT -p tcp --syn -m state --state NEW --dport 21 -j ACCEPT
iptables -t filter -A INPUT -p tcp --syn -m state --state NEW --dport 22 -j ACCEPT
iptables -t filter -A INPUT -p tcp --syn -m state --state NEW --dport 23 -j ACCEPT
iptables -t filter -A INPUT -p tcp --syn -m state --state NEW --dport 25 -j ACCEPT
iptables -t filter -A INPUT -p tcp --syn -m state --state NEW --dport 80 -j ACCEPT
iptables -t filter -A INPUT -p tcp --syn -m state --state NEW --dport 110 -j ACCEPT
iptables -t filter -A INPUT -p tcp --syn -m state --state NEW --dport 443 -j ACCEPT
這一坨東西和上面那一行使用了-m multiport寫法的指令是同等效力的

再來是脫褲子放P的封包過濾法
假設eth1是防火牆上的內網接口，而eth0是防火牆上的外網接口
原來我們只要寫一行的東西
iptables -t filter -A FORWARD -i eth1 -p tcp --dport 80 -j DROP
可以把它寫成這樣子的兩行
(在PREROUTING鏈不得使用-o eth0所以我沒寫，所以連帶上面的那一行我也沒寫-o eth0)
iptables -t mangle -A PREROUTING -i eth1 -p tcp --dport 80 -j MARK --set-mark 80
iptables -t filter -A FORWARD -p tcp -m mark --mark 80 -j DROP
我完全不知道為什麼要拿石頭砸自已的腳，這樣寫有比較帥嗎？直接識別到封包直接丟掉就好了
為什麼要先蓋上個豬肉章，然後在下一個步驟的FORWARD鏈發現有蓋上豬肉章的封包再丟掉呢？？？
地球上有些問題是沒有答案的，我只要知道比較高效的那種寫法就可以了

再來是奇特的可以判斷封包是本機的那一個用戶產生的機制，注意這裡我強調的「本機」
這個判定封包是那個用戶產生的機制，只能使用於OUTPUT和POSTROUTING鏈
(書上沒寫什麼表的OUTPUT和POSTROUTING鏈，所以也許是所有的有OUTPUT鏈和POSTROUTING鏈的表都能使用，不過這個功能我應該用不到)
以下是實際用法，限制本機用戶anntony只能瀏覽網頁
iptables -t filter -A OUTPUT -p tcp --dport 80 -m owner --uid-owner anntony -j ACCEPT
iptables -t filter -A OUTPUT -p tcp --dport 443 -m owner --uid-owner anntony -j ACCEPT
iptables -t filter -A OUTPUT -p udp --dport 53 -m owner --uid-owner anntony -j ACCEPT
iptables -t filter -A OUTPUT -p all -m owner --uid-owner anntony -j DROP
或是用剛才學來的multiport縮寫成三行
iptables -t filter -A OUTPUT -p tcp -m multiport --dports 80,443 -m owner --uid-owner anntony -j ACCEPT
iptables -t filter -A OUTPUT -p udp --dport 53 -m owner --uid-owner anntony -j ACCEPT
iptables -t filter -A OUTPUT -p all -m owner --uid-owner anntony -j DROP

上面是指定由本機單一用戶所產生的封包處置，接下來是本機單一群組所產生的封包處置
把上例再擴大成「本機的anntony群組」只能瀏覽網頁
指令看起來和上面超像，差別只在--uid-owner換成--gid-owner而已
iptables -t filter -A OUTPUT -p tcp --dport 80 -m owner --gid-owner anntony -j ACCEPT
iptables -t filter -A OUTPUT -p tcp --dport 443 -m owner --gid-owner anntony -j ACCEPT
iptables -t filter -A OUTPUT -p udp --dport 53 -m owner --gid-owner anntony -j ACCEPT
iptables -t filter -A OUTPUT -p all -m owner --gid-owner anntony -j DROP
或是用剛才學來的multiport縮寫成三行
iptables -t filter -A OUTPUT -p tcp -m multiport --dports 80,443 -m owner --gid-owner anntony -j ACCEPT
iptables -t filter -A OUTPUT -p udp --dport 53 -m owner --gid-owner anntony -j ACCEPT
iptables -t filter -A OUTPUT -p all -m owner --gid-owner anntony -j DROP

再來是匹配某個區間的IP段
例如192.168.0.2到192.168.0.61這一個區段的主機都不可以連接到本機
除了呆呆的這樣寫，從2寫到3寫到4一路寫到61這種蠢方法之外
iptables -t filter -A INPUT -p all -s 192.168.0.2 -j DROP
iptables -t filter -A INPUT -p all -s 192.168.0.3 -j DROP
iptables -t filter -A INPUT -p all -s 192.168.0.4 -j DROP
(繼續寫…一直寫…)
iptables -t filter -A INPUT -p all -s 192.168.0.60 -j DROP
iptables -t filter -A INPUT -p all -s 192.168.0.61 -j DROP
(就這樣一共寫了60行哈哈回到了兒時的天真)

或者是稍微再高級一點的寫法
寫成
iptables -t filter -A INPUT -p all -s 192.168.0.1 -j ACCEPT
iptables -t filter -A INPUT -p all -s 192.168.0.62 -j ACCEPT
iptables -t filter -A INPUT -p all -s 192.168.0.63 -j ACCEPT
iptables -t filter -A INPUT -p all -s 192.168.0.0/26 -j DROP
如果寫成192.168.0.0/26
netmask有26個bit，所以主機地址只剩6個bit
000000 到 111111
換成十進制是 0 到 63
0是網路識別，63是廣播地址
為了不讓192.168.0.1 和 192.168.0.62 和 192.168.0.63 被第4行的DROP規則丟掉，先放他們進來
但是這樣很累，我還要自已去研究要使用幾個bit的netmask最接近我要匹配的網路區段
192.168.0.2 - 192.168.0.61 比較接近 192.168.0.0/26這個CIDR的範圍 192.168.0.1 - 192.168.0.63
先把1和62和63放進來，再把192.168.0.0/26整個區段拒絕
就達成了拒絕192.168.0.2 - 192.168.0.61連續區段IP的效果了，也不用呆呆的寫60行差不多的指令
這樣比起原先那個呆呆60行看起來有巨大的進步
變成只有4行，可是還可以再聰明一點，寫成一行，如下
iptables -t filter -A INPUT -m iprange --src-range 192.168.0.2-192.168.0.61 -j DROP
這樣一行指令就完成了「192.168.0.2 到 192.168.0.61這60台主機都不可以訪問本機」的防火牆規則
如果不允許本機去訪問 192.168.0.101 到 192.168.0.120這20台主機 (也許那裡放著什麼企業裡珍貴的資料)，可以寫成
iptables -t filter -A OUTPUT -m iprange --dst-range 192.168.0.101-192.168.0.120 -j DROP
感謝iprange模組的努力


