(此篇只記錄一些廢話，請不要認真看，因為這篇我寫得很隨便，你如果認真看，我會很不好意思)
iptables -t filter -F
iptables -t filter -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -t filter -A INPUT -i lo -s 127.0.0.1 -d 127.0.0.1 -p all -j ACCEPT
iptables -t filter -A INPUT -i eth0 -s 192.168.0.160 -d 192.168.0.160 -p all -j ACCEPT
iptables -t filter -A INPUT -d 192.168.0.160 -p tcp --dport 36000 -j ACCEPT
iptables -t filter -A INPUT -d 192.168.0.160 -p tcp --dport 80 -j ACCEPT
iptables -t filter -A INPUT -d 192.168.0.160 -p tcp --dport 113 -j ACCEPT
iptables -t filter -A INPUT -s 192.168.0.0/24 -d 192.168.0.160 -p icmp -j ACCEPT
iptables -t filter -P INPUT DROP
iptables -t filter -L -nv --line-number

http://serverfault.com/questions/416537/why-does-a-valid-set-of-iptables-rules-slow-my-server-to-a-crawl
http://www.textndata.com/forums/iptables-firewall-making-smtp-pop3-323613.html

啟用本機防火牆之前，需要先載入ip_tables模組
sudo modprobe ip_tables
sudo echo 'ip_tables' >> /etc/modules

參考資料
http://stackoverflow.com/questions/21983554/iptables-v1-4-14-cant-initialize-iptables-table-nat-table-does-not-exist-d

然後又
iptables v1.4.14: can't initialize iptables table `filter': Permission denied (you must be root)

哇草原因是我白爛把firewall.sh放在/etc/profile.d目錄下
應該要在/etc/rc.local裡面呼叫firewall.sh才對，放在/etc/profile.d幹什麼

網關式防火牆 練習1
對外網卡eth0，對內網卡eth1
限制內網的192.168.0.200只能去10.0.1.100寄信(25)或收信(110)
限制內網的192.168.0.0/24所有IP可以存取Internet上面的25(寄信)110(收信) 80(瀏覽網頁無加密) 443(瀏覽網頁有加密)
限制內網的192.168.0.0/24所有IP可以存取Internet上面的udp 53也就是DNS查詢服務

iptables -t filter -F FORWARD
iptables -t filter -A FORWARD -i eth0 -o eth1 -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -t filter -A FORWARD -i eth1 -o eth0 -s 192.168.0.200 -d 10.0.1.100 -p tcp -m multiport --dports 25,110 -j ACCEPT
iptables -t filter -A FORWARD -i eth1 -o eth0 -s 192.168.0.0/24 -p tcp -m multiport --dports 25,110 -j ACCEPT
iptables -t filter -A FORWARD -i eth1 -o eth0 -s 192.168.0.0/24 -p tcp -m multiport --dports 80,443 -j ACCEPT
iptables -t filter -A FORWARD -i eth1 -o eth0 -s 192.168.0.0/24 -p udp --dport 53 -j ACCEPT
iptables -t filter -P FORWARD DROP

nat表的封包流向
以nat CHAIN iptables當作關鍵字，Google圖片搜尋
幾十個網友畫得圖有些出入，仔細研究一下

讓內部網路使用NAT機制上網
對外網卡eth0，對內網卡eth1
iptables -t nat -A POSTROUTING -o eth0 -s 192.168.5.0/24 -j SNAT --to 118.169.0.31
或是不寫外網IP，直接寫成這樣，與上面那一行顯式指定外網IP的指令同等效力
iptables -t nat -A POSTROUTING -o eth0 -s 192.168.5.0/24 -j MASQUERADE
如果外網是撥接式的ADSL，也可能會寫成這樣
iptables -t nat -A POSTROUTING -o ppp0 -s 192.168.5.0/24 -j MASQUERADE

nat多對多(外網有多個IP，但是一定要連續號碼好討厭，感覺是有錢人才有資格下的指令，我家是用二類電信我連TM一個public IP都沒有)
iptables -t nat -A POSTROUTING -o eth0 -s 192.168.5.0/24 -j SNAT --to 118.169.0.31-118.169.0.35

nat一對一
請準備多個public IP，綁在外網的eth0接口
一個eth0綁上多個IP的參考資料
https://wiki.debian.org/NetworkConfiguration#Multiple_IP_addresses_on_One_Interface
防火牆主機上共有三張網卡，eth0對外，eth1是DMZ區，eth2是企業內部網路
eth0綁上了118.169.0.31和118.169.0.32和118.169.0.33
eth1綁上了192.168.0.254
eth2綁上了192.168.1.254
有一台WWW服務器位於DMZ區內，IP是192.168.0.32
有一台Mail服務器也在DMZ區內，IP是192.168.0.33
目前規劃將外部IP:118.169.0.31當成企業內部nat前方的Public IP
外部IP:118.169.0.32要對映到WWW服務器192.168.0.32
外部IP:118.169.0.33要對映到Mail服務器192.168.0.33
從Internet過來的封包，進入我的WWW服務器的配置是
iptables -t nat -A PREROUTING -i eth0 -d 118.169.0.32 -j DNAT --to 192.168.0.32
如果這台WWW服務器有機會它會主動連到Internet，那麼這個也設一下
iptables -t nat -A POSTROUTING -o eth0 -s 192.168.0.32 -j SNAT --to 118.169.0.32

同樣的原理，你可以推出118.169.0.33要映射給內網裡的Mail服務器，要這樣設定
iptables -t nat -A PREROUTING -i eth0 -d 118.169.0.33 -j DNAT --to 192.168.0.33
iptables -t nat -A POSTROUTING -o eth0 -s 192.168.0.33 -j SNAT --to 118.169.0.33

接下來是我一定會用到的Network Address Port Translation (NAPT)
為什麼一定會用到呢？因為我是個窮逼啊~哈哈哈
上面那個一對一NAT還有3個public IP可以用
現實生活裡我大概申請一個就覺得很貴很貴了，所以就用這個方法來作連接埠映射到內網的服務器
描述一下網路環境
外網eth0，IP是118.169.0.31，就只有這一個寶貴的public IP嗚
內網eth1，連接我們服務器放置的DMZ區，IP是192.168.0.254
內網eth2，連接我們企業內網，IP是192.168.1.254
WWW服務器IP是192.168.0.1
Mail服務器IP是192.168.0.2
我們要將Internet送到eth0的80和443 port轉給192.168.0.1
還有將Internet送到eth0的25和110 port轉給192.168.0.2
封包進來eth0設定是
iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j DNAT --to 192.168.0.1:80
iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 443 -j DNAT --to 192.168.0.1:443
iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 25 -j DNAT --to 192.168.0.2:25
iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 110 -j DNAT --to 192.168.0.2:110
讓這兩台服務器的封包可以出去，將來源改成public IP
iptables -t nat -A POSTROUTING -o eth0 -s 192.168.0.0/24 -j SNAT --to 118.169.0.31

再來看到了mangle表的OUTPUT鏈
我還是一樣先用關鍵字
nat chain iptables
搜尋了Google圖片
這個網頁裡畫的那張Iptables Chains Order Scheme
我覺得最容易理解
參考網頁
http://www.gtcomm.net/blog/linux-native-firewall-introduction-to-iptables/
而且它還有特別標上，你在那個表的那個鏈裡面可以幹什麼事

我真的很好奇書上寫的那個mangle表的OUPUT鏈
真的可以換掉封包裡的DSCP資訊嗎？
所以我就試了一下
在我的CubieTruck上面，由於SSH Server是運行在tcp port 36000
在動手前我先用Wireshark抓了一下
這樣子的封包，也就是CubieTruck上的SSH Server發給我筆記型電腦SSH Client的封包
Src : 192.168.0.160
Dst : 192.168.0.12
Src Port : 36000
Dst Port : 51625(這隨機產生的port number，你的一定和我不一樣)
在Internet Protocol Version 4 , Src :192.168.0.160 ......這行打開
下面有個
Differentiated Services Field : 0x10 (DSCP 0x04: Unknown DSCP; ECN: 0x00: Not-ECT (Not ECN-Capable Transport))
的下面那一行
0001 00.. = Diffreentiated Services Codepoint: Unknown (0x04)
在這裡可以確認DSCP的預設值是十進制的4，也就是那個二進制的0001 00
然後在CubieTruck機器上運行這一行iptables規則，來修改從CubieTruck本機發出的tcp 36000 port的封包的DSCP值
iptables -t mangle -A OUTPUT -p tcp --sport 36000 -j DSCP --set-dscp 63
我故意改成十進制的63，這樣如果待會兒真的生效，就會看到原來預設0001 00的地方，會變成1111 11
改完之後，mangle表的規則如下，只有一條
root@cubie:~# iptables -t mangle -L -nv --line-number
Chain PREROUTING (policy ACCEPT 2903 packets, 292K bytes)
num   pkts bytes target     prot opt in     out     source               destination         

Chain INPUT (policy ACCEPT 2903 packets, 292K bytes)
num   pkts bytes target     prot opt in     out     source               destination         

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
num   pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 3222 packets, 413K bytes)
num   pkts bytes target     prot opt in     out     source               destination         
1     1075  188K DSCP       tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp spt:36000 DSCP set 0x3f

Chain POSTROUTING (policy ACCEPT 3222 packets, 413K bytes)
num   pkts bytes target     prot opt in     out     source               destination         
root@cubie:~# 
然後再次打開Wireshark來抓封包
一樣是抓
Src : 192.168.0.160
Dst : 192.168.0.12
Src Port : 36000
Dst Port : 51625(這隨機產生的port number，你的一定和我不一樣)
這種類型的封包，然後觀察DSCP的部分，變成了
1111 11.. = Differentiated Services Codepoint: Unknown (0x3f)
太神奇了，只是改這個要幹什麼呢？
看完這本五百頁的書應該就會知道了，現在才一百零五頁

突然發現這張iptables封包的過濾流程圖也畫得很清楚
而且連raw表也加了進去
http://serverfault.com/questions/523589/is-there-any-way-to-filter-packets-eg-by-iptables-after-routing-is-complete

在防火牆主機上，使用filter表的FORWARD鏈來保護企業內部的WWW服務器(192.168.5.1)不被外部IP 11.22.33.44存取
iptables -t filter -A FORWARD -i eth0 -s 11.22.33.44 -d 192.168.5.1 -j DROP
寫這一行規則的時候，要記得封包到達filter表的FORWARD鏈之前
已經先經過了nat表的PREROUTING鏈 
(已經作了DNAT，已經置換掉了封包的Destination IP)
而且外部的那個想進入企業內存取WWW服務器的封包
原來的Source IP應該是11.22.33.44而Destination IP應該是防火牆eth0上面的外部IP
經過了nat表的PREROUTING鏈之後，這個封包已經變成了
Source IP依然不變是11.22.33.44，但是Destination IP被DNAT變成了192.168.5.1
所以我們在這裡的規則是用 -d 192.168.5.1，而不是-d <eth0接口上綁的企業的public IP>

防火牆主機常見的filter表的FORWARD鏈過濾規則寫法
對外接口eth0，對內接口eth1

1.不允許企業內部用戶訪問www.xvideos.com
iptables -t filter -A FORWARD -p tcp -i eth1 -o eth0 -d www.xvideos.com -j DROP

順便一提，上面的這一句規則會一口氣加上十條規則在FORWARD鏈
原因是www.xvideos.com這個域名有對應到10個IPv4地址
可以這樣用nslookup查詢
$ nslookup www.xvideos.com 8.8.8.8

然後會得到
Server:		8.8.8.8
Address:	8.8.8.8#53

Non-authoritative answer:
www.xvideos.com	canonical name = xvideos.com.
Name:	xvideos.com
Address: 141.0.174.44
Name:	xvideos.com
Address: 141.0.174.34
Name:	xvideos.com
Address: 141.0.174.35
Name:	xvideos.com
Address: 141.0.174.36
Name:	xvideos.com
Address: 141.0.174.37
Name:	xvideos.com
Address: 141.0.174.38
Name:	xvideos.com
Address: 141.0.174.40
Name:	xvideos.com
Address: 141.0.174.41
Name:	xvideos.com
Address: 141.0.174.42
Name:	xvideos.com
Address: 141.0.174.43

看一下加入那條禁看www.xvideos.com的規則之後，filter表的FORWARD鏈規則現在是？
root@cubie:~# iptables -t filter -L FORWARD -nv --line-number
Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
num   pkts bytes target     prot opt in     out     source               destination         
1        0     0 DROP       tcp  --  eth1   eth0    0.0.0.0/0            141.0.174.36        
2        0     0 DROP       tcp  --  eth1   eth0    0.0.0.0/0            141.0.174.43        
3        0     0 DROP       tcp  --  eth1   eth0    0.0.0.0/0            141.0.174.40        
4        0     0 DROP       tcp  --  eth1   eth0    0.0.0.0/0            141.0.174.44        
5        0     0 DROP       tcp  --  eth1   eth0    0.0.0.0/0            141.0.174.38        
6        0     0 DROP       tcp  --  eth1   eth0    0.0.0.0/0            141.0.174.41        
7        0     0 DROP       tcp  --  eth1   eth0    0.0.0.0/0            141.0.174.34        
8        0     0 DROP       tcp  --  eth1   eth0    0.0.0.0/0            141.0.174.37        
9        0     0 DROP       tcp  --  eth1   eth0    0.0.0.0/0            141.0.174.42        
10       0     0 DROP       tcp  --  eth1   eth0    0.0.0.0/0            141.0.174.35        
root@cubie:~# 

2.不允許Internet的11.22.33.44主機訪問公司內部的WWW服務器(192.168.0.1)
iptables -t filter -A FORWARD -i eth0 -o eth1 -s 11.22.33.44 -d 192.168.0.1 -p tcp --dport 80 -j DROP

3.不允許icmp request (type 8)，別人不能ping我，但是我可以ping別人 (突然想起三國的曹操)
iptables -t filter -A FORWARD -p icmp --icmp-type 8 -j DROP

4.不允許內網的用戶使用FTP客戶端下載Internet上的任何東西
iptables -t filter -A FORWARD -i eth1 -o eth0 -s 192.168.0.0/24 -p tcp --dport 21 -j DROP

使用關鍵字3 way handshake
進行Google圖片搜尋

原來的本機防火牆規則的這二條
是我用來放行自定義SSH Server的tcp port 36000
iptables -t filter -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -t filter -A INPUT -d 192.168.0.160 -p tcp --dport 36000 -j ACCEPT

但是這樣不夠嚴謹
可以改成
iptables -t filter -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -t filter -A INPUT -d 192.168.0.160 -p tcp --dport 36000 --syn -m state --state NEW -j ACCEPT

第二行的意思是與本機的tcp port 36000建立tcp連線的過程裡
3 way handshake的第一個封包(-m state--state NEW)裡syn這個flag有設定的話，就放行
這麼作是為了避免黑客在建立tcp連線之前，就直接對tcp port 36000發送fin封包，或是syn和fin這兩個flag都有設定的怪異封包
那種詭異的封包如果通過本機防火牆進入本機程序，不知道會發生什麼事 (要不看到臉，要不看到後腦勺，兩個同時看到就崩潰進神經病院了)
所以這樣的寫法，比先前只是單純讓tcp port 36000打開接受連線，安全強度要更高

同理可推出，那麼我先前的本機防火牆，除了tcp port 36000還開了tcp port 80
那一條「只是打開tcp port 80」的本機防火牆規則是
iptables -t filter -A INPUT -d 192.168.0.160 -p tcp --dport 80 -j ACCEPT
應該要拿掉上面這行，改成下面這一行
iptables -t filter -A INPUT -d 192.168.0.160 -p tcp --dport 80 --syn -m state --state NEW -j ACCEPT

以下規則為所有tcp封包作過濾，檢查封包裡所有的TCP-Flags
當syn和fin同時被標示為1的時候，將此封包丟棄，因為不可能同時既要求連線(syn)又要求斷線(fin)
iptables -t filter -A INPUT -p tcp --tcp-flags ALL SYN,FIN -j DROP

以下規則和上面那條很像，差別是只檢查syn和fin兩個TCP-Flags
當syn和fin同時被標示為1的時候，將此封包丟棄
iptables -t filter -A INPUT -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP

接下來這一條規則也是用在本機防火牆上
想要存取本機tcp port 3306的封包，來源只能是特定mac address的網卡才可以放行
iptables -t filter -A INPUT -p tcp --dport 3306 -m mac --mac-source 9c:d2:1e:f1:0a:53 -j ACCEPT

然後是在防火牆主機上管制網卡mac address的技巧
產生一個可以使用企業網路資源的合法mac address列表，只有裡面記錄的mac address可以使用企業的網路資源
檔名是/root/mac_lists
內容如下
00:0A:C3:82:71:5C
00:22:33:44:55:66

接著在/root/firewall.sh加上
cat /root/mac_lists | while read MAC
do
    MAC=$( echo $MAC | awk '{print $1}' )
    iptables -t filter -A FORWARD -i eth1 -o eth0 -m mac --mac-source $MAC -j ACCEPT
done

再來是multiport的寫法
iptables -t filter -A INPUT -p tcp --syn -m state --state NEW  -m multiport --dports 21,22,23,25,80,110,443 -j ACCEPT

你也可以畫蛇添足，將上面簡單的那一行，改寫成
iptables -t filter -A INPUT -p tcp --syn -m state --state NEW --dport 21 -j ACCEPT
iptables -t filter -A INPUT -p tcp --syn -m state --state NEW --dport 22 -j ACCEPT
iptables -t filter -A INPUT -p tcp --syn -m state --state NEW --dport 23 -j ACCEPT
iptables -t filter -A INPUT -p tcp --syn -m state --state NEW --dport 25 -j ACCEPT
iptables -t filter -A INPUT -p tcp --syn -m state --state NEW --dport 80 -j ACCEPT
iptables -t filter -A INPUT -p tcp --syn -m state --state NEW --dport 110 -j ACCEPT
iptables -t filter -A INPUT -p tcp --syn -m state --state NEW --dport 443 -j ACCEPT
這一坨東西和上面那一行使用了-m multiport寫法的指令是同等效力的

再來是脫褲子放P的封包過濾法
假設eth1是防火牆上的內網接口，而eth0是防火牆上的外網接口
原來我們只要寫一行的東西
iptables -t filter -A FORWARD -i eth1 -p tcp --dport 80 -j DROP
可以把它寫成這樣子的兩行
(在PREROUTING鏈不得使用-o eth0所以我沒寫，所以連帶上面的那一行我也沒寫-o eth0)
iptables -t mangle -A PREROUTING -i eth1 -p tcp --dport 80 -j MARK --set-mark 80
iptables -t filter -A FORWARD -p tcp -m mark --mark 80 -j DROP
我完全不知道為什麼要拿石頭砸自已的腳，這樣寫有比較帥嗎？直接識別到封包直接丟掉就好了
為什麼要先蓋上個豬肉章，然後在下一個步驟的FORWARD鏈發現有蓋上豬肉章的封包再丟掉呢？？？
地球上有些問題是沒有答案的，我只要知道比較高效的那種寫法就可以了

再來是奇特的可以判斷封包是本機的那一個用戶產生的機制，注意這裡我強調的「本機」
這個判定封包是那個用戶產生的機制，只能使用於OUTPUT和POSTROUTING鏈
(書上沒寫什麼表的OUTPUT和POSTROUTING鏈，所以也許是所有的有OUTPUT鏈和POSTROUTING鏈的表都能使用，不過這個功能我應該用不到)
以下是實際用法，限制本機用戶anntony只能瀏覽網頁
iptables -t filter -A OUTPUT -p tcp --dport 80 -m owner --uid-owner anntony -j ACCEPT
iptables -t filter -A OUTPUT -p tcp --dport 443 -m owner --uid-owner anntony -j ACCEPT
iptables -t filter -A OUTPUT -p udp --dport 53 -m owner --uid-owner anntony -j ACCEPT
iptables -t filter -A OUTPUT -p all -m owner --uid-owner anntony -j DROP
或是用剛才學來的multiport縮寫成三行
iptables -t filter -A OUTPUT -p tcp -m multiport --dports 80,443 -m owner --uid-owner anntony -j ACCEPT
iptables -t filter -A OUTPUT -p udp --dport 53 -m owner --uid-owner anntony -j ACCEPT
iptables -t filter -A OUTPUT -p all -m owner --uid-owner anntony -j DROP

上面是指定由本機單一用戶所產生的封包處置，接下來是本機單一群組所產生的封包處置
把上例再擴大成「本機的anntony群組」只能瀏覽網頁
指令看起來和上面超像，差別只在--uid-owner換成--gid-owner而已
iptables -t filter -A OUTPUT -p tcp --dport 80 -m owner --gid-owner anntony -j ACCEPT
iptables -t filter -A OUTPUT -p tcp --dport 443 -m owner --gid-owner anntony -j ACCEPT
iptables -t filter -A OUTPUT -p udp --dport 53 -m owner --gid-owner anntony -j ACCEPT
iptables -t filter -A OUTPUT -p all -m owner --gid-owner anntony -j DROP
或是用剛才學來的multiport縮寫成三行
iptables -t filter -A OUTPUT -p tcp -m multiport --dports 80,443 -m owner --gid-owner anntony -j ACCEPT
iptables -t filter -A OUTPUT -p udp --dport 53 -m owner --gid-owner anntony -j ACCEPT
iptables -t filter -A OUTPUT -p all -m owner --gid-owner anntony -j DROP

再來是匹配某個區間的IP段
例如192.168.0.2到192.168.0.61這一個區段的主機都不可以連接到本機
除了呆呆的這樣寫，從2寫到3寫到4一路寫到61這種蠢方法之外
iptables -t filter -A INPUT -p all -s 192.168.0.2 -j DROP
iptables -t filter -A INPUT -p all -s 192.168.0.3 -j DROP
iptables -t filter -A INPUT -p all -s 192.168.0.4 -j DROP
(繼續寫…一直寫…)
iptables -t filter -A INPUT -p all -s 192.168.0.60 -j DROP
iptables -t filter -A INPUT -p all -s 192.168.0.61 -j DROP
(就這樣一共寫了60行哈哈回到了兒時的天真)

或者是稍微再高級一點的寫法
寫成
iptables -t filter -A INPUT -p all -s 192.168.0.1 -j ACCEPT
iptables -t filter -A INPUT -p all -s 192.168.0.62 -j ACCEPT
iptables -t filter -A INPUT -p all -s 192.168.0.63 -j ACCEPT
iptables -t filter -A INPUT -p all -s 192.168.0.0/26 -j DROP
如果寫成192.168.0.0/26
netmask有26個bit，所以主機地址只剩6個bit
000000 到 111111
換成十進制是 0 到 63
0是網路識別，63是廣播地址
為了不讓192.168.0.1 和 192.168.0.62 和 192.168.0.63 被第4行的DROP規則丟掉，先放他們進來
但是這樣很累，我還要自已去研究要使用幾個bit的netmask最接近我要匹配的網路區段
192.168.0.2 - 192.168.0.61 比較接近 192.168.0.0/26這個CIDR的範圍 192.168.0.1 - 192.168.0.63
先把1和62和63放進來，再把192.168.0.0/26整個區段拒絕
就達成了拒絕192.168.0.2 - 192.168.0.61連續區段IP的效果了，也不用呆呆的寫60行差不多的指令
這樣比起原先那個呆呆60行看起來有巨大的進步
變成只有4行，可是還可以再聰明一點，寫成一行，如下
iptables -t filter -A INPUT -m iprange --src-range 192.168.0.2-192.168.0.61 -j DROP
這樣一行指令就完成了「192.168.0.2 到 192.168.0.61這60台主機都不可以訪問本機」的防火牆規則
如果不允許本機去訪問 192.168.0.101 到 192.168.0.120這20台主機 (也許那裡放著什麼企業裡珍貴的資料)，可以寫成
iptables -t filter -A OUTPUT -m iprange --dst-range 192.168.0.101-192.168.0.120 -j DROP
感謝iprange模組的努力

再來是ttl模組 (Time to Live 字面上翻是存活時間，但是實質意義已經變成封包移動超過該數字的路由器數量就會嗝屁)
丟掉IP包頭裡TTL值「等於」64的封包
iptables -t filter -A INPUT -m ttl --ttl-eq 64 -j DROP
丟掉IP包頭裡TTL值「小於」64的封包
iptables -t filter -A INPUT -m ttl --ttl-lt 64 -j DROP
丟掉IP包頭裡TTL值「大於」64的封包
iptables -t filter -A INPUT -m ttl --ttl-gt 64 -j DROP

Linux發出的封包預設的TTL值是64，而Windows是128
封包每經過一個路由器，其TTL值會減少1，當變成0的時候，會被路由器丟棄掉
不過在這裡我搞不懂為什麼要來匹配TTL值，然後對TTL值「等於」或是「大於」或是「小於」某個數字(例如64)的封包來作出處置
如果來到我的防火牆主機上，TTL值只剩54，那麼表示這個封包旅行了經過了10個路由器來到我這裡
接著我處置這個封包，也許接受、也許丟棄，和它的旅行的哩程數有什麼直接關係呢？
跑得太遠了，殺，或是跑得不夠遠，殺，或是跑得剛好是經過了N個路由器一個不多一個不少，殺
這樣有點怪怪的，暫時無法理解此模組的意圖

接下來是過濾ah和esp包頭裡的spi值
我只是照著書上教的，事實上我在看完這十幾頁之後我還是完全搞不懂偉大的作者想告訴我什麼東西
這裡講到的技術名詞ah、esp、spi值好像是和IPSec有關
很遺憾我也不知道IPSec是什麼，感覺好像是和VPN有關係的東西
我大概再翻幾千頁手冊就會懂了 (光想就覺得很可悲)…應該吧…不過太嘴砲的東西、無法操作的東西、太抽象的東西我通常沒什麼興趣繼續深究
我關注的是正常人會用到的東西，抱怨結束，指令如下
iptables -t filter -A FORWARD -p ah -m ah --ahspi 300 -j ACCEPT
iptables -t filter -A FORWARD -p esp -m esp --espspi 200 -j ACCEPT
以上兩條規則是用來放行ah包頭裡spi值為300的封包
以及esp包頭裡spi值為200的封包

再來是禁止icmp協定的ping broadcast也就是執行 ping -b 192.168.0.255
然後故意去ping區網的廣播地址這樣的封包
這樣該區網內所有主機都會收到一個icmp request包，然後所有區網內的主機再回覆發送端主機一個icmp response封包
如果有心人把發送端主機的IP改成那個他想要攻擊的某一台區網主機IP
透過大量收到區網內所有主機icmp response封包的方式，可以癱瘓掉該台主機
iptables -A FORWARD -p icmp -m pkttype --pkt-type broadcast -j DROP

接下來要講icmp封包的MTU
我打開了筆記型電腦(192.168.0.12)的終端機，然後執行
# ping 192.168.0.160
就這樣讓筆記型電腦一直ping我的CubieTruck
然後打開了安裝在筆記型電腦上的Wireshark，抓wlan0介面的封包來分析
只看這種封包
Source : 192.168.0.12
Destination : 192.168.0.160
Protocal : ICMP
然後在Wireshark中間的面版，可以看到
> Frame 229: 98 bytes on wire (784 bits), 98 bytes captured (784 bits) on interface 0
> Ethernet II, Src: HonHaiPr_f1:0a:53 (9c:d2:1e:f1:0a:53), Dst: 02:cc:02:42:95:d3 (02:cc:02:42:95:d3)
> Internet Protocol Version 4, Src: 192.168.0.12 (192.168.0.12), Dst: 192.168.0.160 (192.168.0.160)
> Internet Control Message Protocol

在第一行可以看到抓到的icmp封包長度是98 bytes
把滑鼠點在這四行的任何一行，然後在Wireshark軟體的最下方的狀態列可以看到每個部分有不同的長度
狀態列依照我點的行數，結果如下
第一行: Frame (frame), 98 bytes
第二行: Ethernet (eth), 14 bytes
第三行: Internet Protocol Version 4(ip), 20 bytes
第四行: Internet Control Message Protocol(icmp), 64 bytes

上面可以看出一個公式
第一行的bytes數 = 第二行的bytes數 + 第三行的bytes數 + 第四行的bytes數
98 = 14 + 20 + 64
如果照著書上教的，icmp封包的MTU的長度(length)應該是不計算第二行的Ethernet包頭的14 bytes
也就是只算第三行的bytes數+第四行的bytes數
也就是IP包頭的20 bytes加上ICMP包頭的64 bytes = 20 + 64 = 84 bytes

如果照著書上講的，那麼我的Linux系統發出的icmp封包的MTU長度應該是84 bytes
不過在Wireshark裡我看到抓到的icmp封包，如果連第二行Ethernet的那14個bytes也加進去，應該是98個bytes
所以Linux系統發出的icmp封包，MTU長度到底要算是98 bytes還是84 bytes？
我很想知道作者在書上講的到底是不是真的？
所以我作了個小實驗
現在我的CubieTruck的本機防火牆也就是filter表的INPUT鏈規則如下
root@cubie:~# iptables -t filter -L INPUT -nv --line-number
Chain INPUT (policy DROP 5 packets, 268 bytes)
num   pkts bytes target     prot opt in     out     source               destination         
1     221K   18M ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            state RELATED,ESTABLISHED
2        1    60 ACCEPT     all  --  lo     *       127.0.0.1            127.0.0.1           
3        0     0 ACCEPT     all  --  eth0   *       192.168.0.160        192.168.0.160       
4        1    60 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.160        tcp dpt:36000flags: 0x17/0x02 state NEW
5        0     0 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.160        tcp dpt:80flags: 0x17/0x02 state NEW
6        2   168 ACCEPT     icmp --  *      *       192.168.0.0/24       192.168.0.160       
root@cubie:~#

這時候在筆記型電腦(192.168.0.12)這裡是可以ping到CubieTruck的
anntony@anntony-Lenovo-B590 ~/cubian_memo $ ping 192.168.0.160
PING 192.168.0.160 (192.168.0.160) 56(84) bytes of data.
64 bytes from 192.168.0.160: icmp_seq=1 ttl=64 time=1.17 ms
64 bytes from 192.168.0.160: icmp_seq=2 ttl=64 time=1.14 ms
64 bytes from 192.168.0.160: icmp_seq=3 ttl=64 time=1.18 ms
^C
--- 192.168.0.160 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2001ms
rtt min/avg/max/mdev = 1.141/1.164/1.183/0.043 ms
anntony@anntony-Lenovo-B590 ~/cubian_memo $

然後我在CubieTruck (192.168.0.160)的本機防火牆裡加入了這一行規則
(第6條規則會把來自192.168.0.0/24區網內所有主機的icmp封包都放行，所以我必須把這條規則插在第6條，而原來的第6條會被擠到第7條)
iptables -t filter -I INPUT 6 -p icmp --icmp-type 8 -m length --length 84 -j DROP

再看一下現在插入上面這條規則之後，CubieTruck本機防火牆的filter表的INPUT鏈規則變成了？
root@cubie:~# iptables -t filter -L INPUT -nv --line-number
Chain INPUT (policy DROP 1 packets, 68 bytes)
num   pkts bytes target     prot opt in     out     source               destination         
1     234K   19M ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            state RELATED,ESTABLISHED
2        1    60 ACCEPT     all  --  lo     *       127.0.0.1            127.0.0.1           
3        0     0 ACCEPT     all  --  eth0   *       192.168.0.160        192.168.0.160       
4        1    60 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.160        tcp dpt:36000flags: 0x17/0x02 state NEW
5        0     0 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.160        tcp dpt:80flags: 0x17/0x02 state NEW
6        0     0 DROP       icmp --  *      *       0.0.0.0/0            0.0.0.0/0            icmptype 8 length 84
7        6   504 ACCEPT     icmp --  *      *       192.168.0.0/24       192.168.0.160       
root@cubie:~#

現在回到筆記型電腦上(192.168.0.12)，試著去ping我們的CubieTruck機器(192.168.0.160)
anntony@anntony-Lenovo-B590 ~/cubian_memo $ ping 192.168.0.160
PING 192.168.0.160 (192.168.0.160) 56(84) bytes of data.
^C
--- 192.168.0.160 ping statistics ---
4 packets transmitted, 0 received, 100% packet loss, time 3022ms

anntony@anntony-Lenovo-B590 ~/cubian_memo $

卡住了，不能ping了，也就是說上面那一條在CubieTruck機器上限制icmp request封包，而且長度是84 bytes的封包的過濾規則生效了
所以可以知道上面那條規則的 -m length --length 84
是不包含第二行也就是 Ethernet (eth)的那14 bytes
所以Linux發出的icmp request封包的MTU大小是84 bytes沒錯
如果還是不信
可以在CubieTruck機器上
把第6條規則刪了
# iptables -t filter -D INPUT 6
加上這條規則
# iptables -t filter -I INPUT 6 -p icmp --icmp-type 8 -m length --length 98 -j DROP
再看看現在CubieTruck機器上的filter表的INPUT鏈
root@cubie:~# iptables -t filter -L INPUT -nv --line-number
Chain INPUT (policy DROP 0 packets, 0 bytes)
num   pkts bytes target     prot opt in     out     source               destination         
1     260K   21M ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            state RELATED,ESTABLISHED
2        1    60 ACCEPT     all  --  lo     *       127.0.0.1            127.0.0.1           
3        0     0 ACCEPT     all  --  eth0   *       192.168.0.160        192.168.0.160       
4        1    60 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.160        tcp dpt:36000flags: 0x17/0x02 state NEW
5        0     0 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.160        tcp dpt:80flags: 0x17/0x02 state NEW
6        0     0 DROP       icmp --  *      *       0.0.0.0/0            0.0.0.0/0            icmptype 8 length 98
7        9   756 ACCEPT     icmp --  *      *       192.168.0.0/24       192.168.0.160       
root@cubie:~#
現在CubieTruck機器上的filter表的INPUT鏈會丟棄掉icmp request而且長度必須是98 bytes的封包
再回到筆記型電腦(192.168.0.12)去ping我們的CubieTruck機(192.168.0.160)
anntony@anntony-Lenovo-B590 ~/cubian_memo $ ping 192.168.0.160
PING 192.168.0.160 (192.168.0.160) 56(84) bytes of data.
64 bytes from 192.168.0.160: icmp_seq=1 ttl=64 time=1.22 ms
64 bytes from 192.168.0.160: icmp_seq=2 ttl=64 time=1.19 ms
64 bytes from 192.168.0.160: icmp_seq=3 ttl=64 time=1.94 ms
^C
--- 192.168.0.160 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2002ms
rtt min/avg/max/mdev = 1.193/1.452/1.944/0.350 ms
anntony@anntony-Lenovo-B590 ~/cubian_memo $
超順暢的，icmp封包有去有回，完全沒被防火牆丟棄
所以這個實驗釐清了我的疑慮
也就是
iptables -t filter -I INPUT 6 -p icmp --icmp-type 8 -m length --length 84 -j DROP
這行規則
--length 84
這個數字必須是84才能捕捉到Linux系統發出的icmp request封包(type 8)
如果你堅持要加上--length 84的話
即使在Wireshark裡面明明抓到的icmp request封包長度是寫98 bytes，但是要扣掉第二行也就是第二行: Ethernet (eth)的14 bytes
變成98 - 14 = 84 bytes
另外由於我的家裡完全沒有Windows機器
所以我不能實驗書上的過濾Windows機器所發出的icmp request封包的規則
iptables -t filter -A INPUT -p icmp --icmp-type 8 -m length --length 92 -j DROP
書上是說Windows系統發出的icmp request封包是92個bytes
不過我沒得實驗就留給其他朋友去試了

再來還是icmp封包的實驗
不過接下來的實驗是有攻擊性的
請不要對著任何外部的主機的IP作這件事
如果被攻擊方的主機和發出指令的主機（就是你的主機）是在相同的國家
而且對方要追究的話，可能會有法律上的責任
如果你是在租來的VPS上面作這件事，可能會被主機商直接砍掉帳號，而且不會退你錢
行前的道德教育結束了
現在來說明一下我的網路環境很簡單
CubieTruck (192.168.0.160)
筆記型電腦 (192.168.0.12)
然後在筆記型電腦上有裝Wireshark
先把Wireshark打開
然後在CubieTruck的終端機，以root用戶提示符執行
# ping -f -s 16384 192.168.0.12
參數-f是像洪水一樣發出ping request，參數-s是指定待送的icmp資料位元數，這裡設定是16384 bytes = 16 Kbytes
接著回到筆記型電腦上面看
十秒鐘不到
Wireshark裡抓到的封包序號從1瞬間爆增到了29133
也就是我在十秒之內立刻在筆記型電腦這裡抓到了二萬九千多個封包
嚇得我趕快在CubieTruck的終端機按下Ctrl + C叫暫停
接著我仔細看了一下
抓到的這些封包大多是第一個icmp封包，長度146 bytes
然後屁股後面會接著11個IPv4的封包，長度是1514 bytes
這12個封包在Wireshark裡被抓到的時候
他們的序號是連在一起的
（連號的鈔票？？）
序號29119的icmp封包是146 bytes
然後序號29120到29130這11個IPv4封包的長度都是1514 bytes
然後我大概計算了一下
十秒二萬九千個封包聽起來很可怕，這樣其實還好
我的算法如下
因為這二萬九千個封包裡有包含了
192.168.0.160 > 192.168.0.12
也有
192.168.0.12 > 192.168.0.160
有ping過去的icmp request，也有ping回來的response
為什麼會被拆成12個封包一組？
(第一個是icmp然後接著11個IPv4封包都是1514 bytes)
是因為在指令裡
ping -f -s 16384 192.168.0.12
我們指定了icmp資料部分的大小是16384 bytes
但是一個封包好像最多只能裝到1514 bytes的樣子
所以每一次發出icmp封包都再被拆成了12個封包 (1個icmp封包後面跟著11個IPv4封包)
所以二萬九千個封包其實只有(29000 除以 12 大約是 2416次，這個數字是發出加上回應的次數 icmp request + icmp response)
如果只算單向又變成了2416 除以 2 = 1208次
十秒發出1208次icmp request，也就是一秒才發出120個icmp request
看起來就沒那麼可怕
可是因為一個肥肥的16384 bytes的icmp封包被拆成12個封包
再加上除了有發出(ping request)，然後也有回應(ping response)
所以變成了那麼可怕的數字，十秒內Wireshark抓到了29133個封包
不過經過這個實驗，我們可以確實明白
只是用ping指令發出icmp封包，是有可能癱瘓掉網路的
如果要加速被攻擊主機的CPU資源消耗，可以改下成
ping -f -s 0 192.168.0.12
這樣相同的單位時間裡可以發出更多的icmp request包，因為體積縮小了，-s 0指定了發送的ICMP包頭裡Data的部分是零

以下的規則限制每分鐘最多只能有10個icmp type 8 (icmp request)包進入
如果超過這個速率，會再被降速成每分鐘只有6個包才能進入
iptables -t filter -A INPUT -p icmp --icmp-type 8 -m limit --limit 6/m --limit-burst 10 -j ACCEPT
iptables -t filter -A INPUT -p icmp --icmp-type 8 -j DROP

值得注意的是，這兩條規則必須要加在
這一條
iptables -t filter -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
規則的前面，不然這兩條限制icmp type 8速率的規則就會完全失效

參考資料在
http://www.spinics.net/lists/netfilter/msg54634.html

裡面老外的重點對話擷取如下:
# ==========================老外的金玉良言開始=====================================================================
I have a problem with the limit module. The goal is to limit the incoming
ICMP echo-requests to max 1/s.
The following rule does it (as example using the INPUT) :

-A INPUT -p icmp -m icmp --icmp-type 8 -m limit --limit 1/sec -j ACCEPT

The above is working fine. But when there is a rule for accepting the
ESTABLISHED packets, the limit does not work:

-A INPUT -p icmp -m icmp --icmp-type 8 -m limit --limit 1/sec -j ACCEPT
-A INPUT -m state --state ESTABLISHED -j ACCEPT

With these 2 rules the limit does not work...
# ==========================老外的金玉良言結束======================================================================

所以這兩條限制icmp type 8流入filter表的INPUT鏈速率的規則
必須要考慮和所有的防火牆規則一起放在同一個shell script裡的時候
他們的先後順序
這是正常的也就是上面那兩行限制icmp type 8流入INPUT鏈速率有正常生效的filter表

root@cubie:~# iptables -t filter -L -nv --line-number
Chain INPUT (policy DROP 1 packets, 32 bytes)
num   pkts bytes target     prot opt in     out     source               destination         
1        0     0 ACCEPT     icmp --  *      *       0.0.0.0/0            0.0.0.0/0            icmptype 8 limit: avg 6/min burst 10
2        0     0 DROP       icmp --  *      *       0.0.0.0/0            0.0.0.0/0            icmptype 8
3      923 72086 ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            state RELATED,ESTABLISHED
4        0     0 ACCEPT     all  --  lo     *       127.0.0.1            127.0.0.1           
5        0     0 ACCEPT     all  --  eth0   *       192.168.0.160        192.168.0.160       
6        1    60 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.160        tcp dpt:36000flags: 0x17/0x02 state NEW
7        0     0 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.160        tcp dpt:80flags: 0x17/0x02 state NEW

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
num   pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 6 packets, 984 bytes)
num   pkts bytes target     prot opt in     out     source               destination         
root@cubie:~#
 
你可以看到即使我的filter表的INPUT鏈預設的規則是DROP
但是我還是在INPUT鏈第2條的地方放上了丟棄所有的icmp type 8封包的規則
在CubieTruck機器上（192.168.0.160）生效的filter表的INPUT鏈如上
然後我們在筆記型電腦（192.168.0.12）來ping看看，到底限速規則是不是真的生效了？

anntony@anntony-Lenovo-B590 ~ $ ping 192.168.0.160
PING 192.168.0.160 (192.168.0.160) 56(84) bytes of data.
64 bytes from 192.168.0.160: icmp_seq=1 ttl=64 time=43.4 ms
64 bytes from 192.168.0.160: icmp_seq=2 ttl=64 time=4.36 ms
64 bytes from 192.168.0.160: icmp_seq=3 ttl=64 time=1.97 ms
64 bytes from 192.168.0.160: icmp_seq=4 ttl=64 time=2.82 ms
64 bytes from 192.168.0.160: icmp_seq=5 ttl=64 time=1.96 ms
64 bytes from 192.168.0.160: icmp_seq=6 ttl=64 time=2.05 ms
64 bytes from 192.168.0.160: icmp_seq=7 ttl=64 time=1.86 ms
64 bytes from 192.168.0.160: icmp_seq=8 ttl=64 time=2.00 ms
64 bytes from 192.168.0.160: icmp_seq=9 ttl=64 time=1.72 ms
64 bytes from 192.168.0.160: icmp_seq=10 ttl=64 time=1.84 ms
64 bytes from 192.168.0.160: icmp_seq=12 ttl=64 time=1.80 ms
64 bytes from 192.168.0.160: icmp_seq=22 ttl=64 time=2.27 ms
64 bytes from 192.168.0.160: icmp_seq=32 ttl=64 time=2.10 ms
64 bytes from 192.168.0.160: icmp_seq=41 ttl=64 time=2.03 ms
64 bytes from 192.168.0.160: icmp_seq=51 ttl=64 time=1.81 ms
^C
--- 192.168.0.160 ping statistics ---
52 packets transmitted, 15 received, 71% packet loss, time 51164ms
rtt min/avg/max/mdev = 1.720/4.938/43.448/10.311 ms
anntony@anntony-Lenovo-B590 ~ $
看著上面的終端機輸出，到第10個ping回應的時候，再下一次就開始被限制速度了
在上面我們設定了每分鐘超過十個包之後要再降到每分鐘6個包的速率
也就是每隔十秒防火牆的filter表的INPUT鏈才會收一個icmp request封包

你可以試著去掉第二條，用這行指令可以去掉INPUT 鏈的第二條
# iptables -t filter -D INPUT 2
然後觀察此時的CubieTruck機器的filter表的INPUT鏈
是否會再繼續限制icmp type 8封包的流入速率？

再次強調
上面的限制icmp request封包流入速率的規則
要
iptables -t filter -A INPUT -p icmp --icmp-type 8 -m limit --limit 6/m --limit-burst 10 -j ACCEPT
iptables -t filter -A INPUT -p icmp --icmp-type 8 -j DROP
這兩條一起使用才有效
注意他們兩個的先後順序
而且上面兩條一定要放在
iptables -t filter -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
這一條規則的前面
否則即使你的filter表的INPUT鏈預設規則已經被設成了DROP
icmp request封包流入的時候還是不會被限制速度
就像什麼事都沒發生一樣

還有如果發送端停止對防火牆主機發送icmp request包
那麼假如防火牆主機已經進入限制速度狀態的6/m也就是每分鐘只允許6個icmp request包流入的狀態
在發送端停止發送icmp request封包之後的6 X 10 = 60秒
在60秒之後又會恢復成每分鐘最多可以10個icmp request包流入的狀態
60秒是第一行規則的 6/m的那個6，乘以--limit-burst的10得來的
不過這裡有點怪怪的
為什麼不是6 X 10 = 60分鐘？規則裡寫的時間單位是分鐘啊？？？

繼續
接著同樣以上面的語法來推測
如果我需要CubieTruck機器上運行的nginx服務器受到保護
我希望在每秒訪問我本機tcp port 80的要求建立新的HTTP連線的SYN_SENT封包
在速率超過每秒40個的時候
就自動降速到只接受每秒20個
那麼防火牆規則應該怎麼寫呢？
如下
iptables -t filter -A INPUT -d 192.168.0.160 -p tcp --dport 80 --syn -m state --state NEW -m limit --limit 20/s --limit-burst 40 -j ACCEPT
iptables -t filter -A INPUT -d 192.168.0.160 -p tcp --dport 80 --syn -m state --state NEW -j DROP
和上面的限制icmp type 8封包的那兩條規則一樣
這兩條一樣是要放在
這一條
iptables -t filter -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
規則的前面才可以發揮限速的功能

然後我又想到如果這樣
那麼我要重新編排CubieTruck本機防火牆規則的順序
改成這樣
這是我的新的/root/firewall.sh

#!/bin/bash
# ============ Set your network parameters here ===================================================
iptables=/sbin/iptables
loopback=127.0.0.1
local=192.168.0.160
lan=192.168.0.0/24
# =================================================================================================
$iptables -t filter -F
$iptables -t filter -A INPUT -i lo -s $loopback -d $loopback -p all -j ACCEPT
$iptables -t filter -A INPUT -i eth0 -s $local -d $local -p all -j ACCEPT
$iptables -t filter -A INPUT -d $local -p tcp --dport 36000 --syn -m state --state NEW -j ACCEPT
$iptables -t filter -A INPUT -d $local -p tcp --dport 80 --syn -m state --state NEW -m limit --limit 20/s --limit-burst 40 -j ACCEPT
$iptables -t filter -A INPUT -d $local -p tcp --dport 80 --syn -m state --state NEW -j DROP
$iptables -t filter -A INPUT -s $lan -d $local -p icmp -j ACCEPT
$iptables -t filter -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
$iptables -t filter -P INPUT DROP
$iptables -t filter -L -n --line-number
# =================================================================================================

接下來要測試限速規則是否有生效
我想一下要怎麼實驗會比較客觀
這樣好了
（一）撤掉CubieTruck機器上的所有防火牆規則，用httperf工具每秒發出60個request，持續20秒，觀察一下可以得到幾個正常的回應（status code 200）
（二）加上防火牆規則，但是不限制HTTP Request封包流入的速度，用httperf工具每秒發出60個request，持續20秒，觀察一下可以得到幾個正常的回應（status code 200）
（三）加上防火牆規則，並限制每秒最多可以流入40個帶有SYN_SENT的HTTP Request，如果超過此速率，就再降速成每秒只允許20個這樣的包流入，
使用httperf工具同上步驟，並觀察可以得到幾個正常的回應 (status code 200)

實驗開始
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
（一）撤掉CubieTruck機器上的所有防火牆規則，用httperf工具每秒發出100個request，持續30秒，觀察一下可以得到幾個正常的回應（status code 200）

在CubieTruck機器上，把防火牆規則完全撤掉，執行
root@cubie:~# iptables -t filter -P INPUT ACCEPT
root@cubie:~# iptables -t filter -F INPUT
root@cubie:~# iptables -t filter -L -nv --line-number
Chain INPUT (policy ACCEPT 81 packets, 6148 bytes)
num   pkts bytes target     prot opt in     out     source               destination         

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
num   pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 41 packets, 4052 bytes)
num   pkts bytes target     prot opt in     out     source               destination         
root@cubie:~# 

在筆記型電腦上，執行
anntony-Lenovo-B590 ~ # httperf --server 192.168.0.160 --port 80 --uri /index.php --rate 60 --num-conn 1200 --num-call 1 --timeout 5
httperf --timeout=5 --client=0/1 --server=192.168.0.160 --port=80 --uri=/index.php --rate=60 --send-buffer=4096 --recv-buffer=16384 --num-conns=1200 --num-calls=1
httperf: warning: open file limit > FD_SETSIZE; limiting max. # of open files to FD_SETSIZE
Maximum connect burst length: 1

Total: connections 1200 requests 865 replies 737 test-duration 26.374 s

Connection rate: 45.5 conn/s (22.0 ms/conn, <=321 concurrent connections)
Connection time [ms]: min 32.7 avg 4389.9 max 8010.9 median 4667.5 stddev 1780.5
Connection time [ms]: connect 702.1
Connection length [replies/conn]: 1.000

Request rate: 32.8 req/s (30.5 ms/req)
Request size [B]: 75.0

Reply rate [replies/s]: min 27.6 avg 27.8 max 28.4 stddev 0.4 (5 samples)
Reply time [ms]: response 3622.6 transfer 97.5
Reply size [B]: header 195.0 content 70191.0 footer 2.0 (total 70388.0)
Reply status: 1xx=0 2xx=737 3xx=0 4xx=0 5xx=0

CPU time [s]: user 1.54 system 24.77 (user 5.8% system 93.9% total 99.8%)
Net I/O: 1923.2 KB/s (15.8*10^6 bps)

Errors: total 463 client-timo 463 socket-timo 0 connrefused 0 connreset 0
Errors: fd-unavail 0 addrunavail 0 ftab-full 0 other 0
anntony-Lenovo-B590 ~ # 

＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
（二）加上防火牆規則，但是不限制HTTP Request封包流入的速度，用httperf工具每秒發出60個request，持續20秒，觀察一下可以得到幾個正常的回應（status code 200）

在CubieTruck機器上，用root用戶登入
然後修改/root/firewall.sh
修改成舊的還沒有限制tcp 80 port流入速率的樣子
如下
#!/bin/bash
# ============ Set your network parameters here ===================================================
iptables=/sbin/iptables
loopback=127.0.0.1
local=192.168.0.160
lan=192.168.0.0/24
# =================================================================================================
$iptables -t filter -F
$iptables -t filter -A INPUT -i lo -s $loopback -d $loopback -p all -j ACCEPT
$iptables -t filter -A INPUT -i eth0 -s $local -d $local -p all -j ACCEPT
$iptables -t filter -A INPUT -d $local -p tcp --dport 36000 --syn -m state --state NEW -j ACCEPT
$iptables -t filter -A INPUT -d $local -p tcp --dport 80 --syn -m state --state NEW -j ACCEPT
$iptables -t filter -A INPUT -s $lan -d $local -p icmp -j ACCEPT
$iptables -t filter -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
$iptables -t filter -P INPUT DROP
$iptables -t filter -L -n --line-number
# =================================================================================================
再執行它一次讓它裡面寫的防火牆規則生效
root@cubie:~# /root/firewall.sh 
Chain INPUT (policy DROP)
num  target     prot opt source               destination         
1    ACCEPT     all  --  127.0.0.1            127.0.0.1           
2    ACCEPT     all  --  192.168.0.160        192.168.0.160       
3    ACCEPT     tcp  --  0.0.0.0/0            192.168.0.160        tcp dpt:36000flags: 0x17/0x02 state NEW
4    ACCEPT     tcp  --  0.0.0.0/0            192.168.0.160        tcp dpt:80flags: 0x17/0x02 state NEW
5    ACCEPT     icmp --  192.168.0.0/24       192.168.0.160       
6    ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0            state RELATED,ESTABLISHED

Chain FORWARD (policy ACCEPT)
num  target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
num  target     prot opt source               destination         
root@cubie:~# 

到筆記型電腦上，一樣執行
anntony-Lenovo-B590 ~ # httperf --server 192.168.0.160 --port 80 --uri /index.php --rate 60 --num-conn 1200 --num-call 1 --timeout 5
httperf --timeout=5 --client=0/1 --server=192.168.0.160 --port=80 --uri=/index.php --rate=60 --send-buffer=4096 --recv-buffer=16384 --num-conns=1200 --num-calls=1
httperf: warning: open file limit > FD_SETSIZE; limiting max. # of open files to FD_SETSIZE
Maximum connect burst length: 4

Total: connections 1200 requests 1052 replies 1015 test-duration 25.439 s

Connection rate: 47.2 conn/s (21.2 ms/conn, <=288 concurrent connections)
Connection time [ms]: min 90.3 avg 3298.5 max 7922.3 median 3418.5 stddev 1647.0
Connection time [ms]: connect 527.9
Connection length [replies/conn]: 1.000

Request rate: 41.4 req/s (24.2 ms/req)
Request size [B]: 75.0

Reply rate [replies/s]: min 38.6 avg 39.7 max 40.6 stddev 0.8 (5 samples)
Reply time [ms]: response 2712.5 transfer 82.6
Reply size [B]: header 195.0 content 70191.0 footer 2.0 (total 70388.0)
Reply status: 1xx=0 2xx=1015 3xx=0 4xx=0 5xx=0

CPU time [s]: user 1.77 system 23.59 (user 7.0% system 92.7% total 99.7%)
Net I/O: 2745.6 KB/s (22.5*10^6 bps)

Errors: total 185 client-timo 185 socket-timo 0 connrefused 0 connreset 0
Errors: fd-unavail 0 addrunavail 0 ftab-full 0 other 0
anntony-Lenovo-B590 ~ #

＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
（三）加上防火牆規則，並限制每秒最多可以流入40個帶有SYN_SENT的HTTP Request，如果超過此速率，就再降速成每秒只允許20個這樣的包流入，
使用httperf工具同上步驟，並觀察可以得到幾個正常的回應 (status code 200)

然後在CubieTruck機器上，把/root/firewall.sh改成有限制tcp port 80速度的
如下
#!/bin/bash
# ============ Set your network parameters here ===================================================
iptables=/sbin/iptables
loopback=127.0.0.1
local=192.168.0.160
lan=192.168.0.0/24
# =================================================================================================
$iptables -t filter -F
$iptables -t filter -A INPUT -i lo -s $loopback -d $loopback -p all -j ACCEPT
$iptables -t filter -A INPUT -i eth0 -s $local -d $local -p all -j ACCEPT
$iptables -t filter -A INPUT -d $local -p tcp --dport 36000 --syn -m state --state NEW -j ACCEPT
$iptables -t filter -A INPUT -d $local -p tcp --dport 80 --syn -m state --state NEW -m limit --limit 20/s --limit-burst 40 -j ACCEPT
$iptables -t filter -A INPUT -d $local -p tcp --dport 80 --syn -m state --state NEW -j DROP
$iptables -t filter -A INPUT -s $lan -d $local -p icmp -j ACCEPT
$iptables -t filter -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
$iptables -t filter -P INPUT DROP
$iptables -t filter -L -n --line-number
# =================================================================================================

接著再執行它一次，讓寫在裡面的防火牆規則生效
root@cubie:~# /root/firewall.sh 
Chain INPUT (policy DROP)
num  target     prot opt source               destination         
1    ACCEPT     all  --  127.0.0.1            127.0.0.1           
2    ACCEPT     all  --  192.168.0.160        192.168.0.160       
3    ACCEPT     tcp  --  0.0.0.0/0            192.168.0.160        tcp dpt:36000flags: 0x17/0x02 state NEW
4    ACCEPT     tcp  --  0.0.0.0/0            192.168.0.160        tcp dpt:80flags: 0x17/0x02 state NEW limit: avg 20/sec burst 40
5    DROP       tcp  --  0.0.0.0/0            192.168.0.160        tcp dpt:80flags: 0x17/0x02 state NEW
6    ACCEPT     icmp --  192.168.0.0/24       192.168.0.160       
7    ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0            state RELATED,ESTABLISHED

Chain FORWARD (policy ACCEPT)
num  target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
num  target     prot opt source               destination         
root@cubie:~#

然後在筆記型電腦上，執行
anntony-Lenovo-B590 ~ # httperf --server 192.168.0.160 --port 80 --uri /index.php --rate 60 --num-conn 1200 --num-call 1 --timeout 5
httperf --timeout=5 --client=0/1 --server=192.168.0.160 --port=80 --uri=/index.php --rate=60 --send-buffer=4096 --recv-buffer=16384 --num-conns=1200 --num-calls=1
httperf: warning: open file limit > FD_SETSIZE; limiting max. # of open files to FD_SETSIZE
Maximum connect burst length: 1

Total: connections 1200 requests 499 replies 499 test-duration 24.934 s

Connection rate: 48.1 conn/s (20.8 ms/conn, <=206 concurrent connections)
Connection time [ms]: min 31.4 avg 513.6 max 3094.8 median 64.5 stddev 849.4
Connection time [ms]: connect 344.1
Connection length [replies/conn]: 1.000

Request rate: 20.0 req/s (50.0 ms/req)
Request size [B]: 75.0

Reply rate [replies/s]: min 20.0 avg 22.0 max 27.6 stddev 3.8 (4 samples)
Reply time [ms]: response 133.2 transfer 36.4
Reply size [B]: header 195.0 content 70191.0 footer 2.0 (total 70388.0)
Reply status: 1xx=0 2xx=499 3xx=0 4xx=0 5xx=0

CPU time [s]: user 2.43 system 22.45 (user 9.7% system 90.0% total 99.8%)
Net I/O: 1377.1 KB/s (11.3*10^6 bps)

Errors: total 701 client-timo 701 socket-timo 0 connrefused 0 connreset 0
Errors: fd-unavail 0 addrunavail 0 ftab-full 0 other 0
anntony-Lenovo-B590 ~ #

＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
對照上面三組的實驗數據，可以知道我們加進的防火牆規則，真的把流入filter表INPUT鏈的tcp port 80有SYN_SENT的這種封包限制速度了
太累了
